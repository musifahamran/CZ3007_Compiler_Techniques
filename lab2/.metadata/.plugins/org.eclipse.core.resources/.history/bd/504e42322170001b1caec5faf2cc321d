// package the generated Java class lives in; no need to change this
%package "parser";

// name of the generated Java class; no need to change this
%class "Parser";

// no need to change this either
%embed {:
	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}
:};

// the list of all terminals; no need to change this
%terminals MODULE, INT, VOID, IF, ELSE, WHILE, RETURN, BREAK, BOOLEAN, PUBLIC, TRUE, FALSE,
           INT_LITERAL, STRING_LITERAL, ID, TYPE, IMPORT,
           PLUS, MINUS, TIMES, DIV, MOD, EQEQ, NEQ, LEQ, GEQ, LT, GT,
           LBRACKET, RPAREN, COMMA, RCURLY, LCURLY, SEMICOLON, RBRACKET, LPAREN, EQL;
           
// declaration of start symbol; no need to change this
%goal Module;

// temporary declaration, you can remove this once you have written all other rules
%goal Dummy;

/* TODO: Flesh out the rule for Module, and add rules for other nonterminals. Here is an example
         of a rule you may want to add:
*/         
   Accessibility = PUBLIC
		  |
		  ;
 

Module = MODULE ID LCURLY Imports Declarations RCURLY;

Imports = Import Imports
		  |
		  ;
		  
Import = IMPORT ID SEMICOLON;

Declarations = Declaration Declarations
		  |
		  ;
		  
Declaration = FunctionDeclaration
		  | FieldDeclaration
		  | TypeDeclaration
		  ;
		  
FunctionDelcaration = Accessibility TypeName ID LPAREN ParameterList RPAREN LCURLY StatementList RCURLY;

FieldDeclaration = Accessibility TypeName ID SEMICOLON;

TypeDeclaration = Accessibility TYPE ID EQL STRING_LITERAL SEMICOLON;

TypeName = PrimitiveType
		  | ArrayType
		  | ID
		  ;
		  
PrimitiveType = VOID
			| BOOLEAN
			| INT
			;
			
ArrayType = ArrayType LBRACKET RBRACKET
			| PrimitiveType LBRACKET RBRACKET
			| ID LBRACKET RBRACKET
			;
			
ParameterList = ParameterList COMMA Parameter
			|
			;
			
Parameter = TypeName ID;

StatementList = StatementList Statement
			| 
			;

Statement = LocalVar
		| BlockOfStatements
		;

LocalVar = TypeName ID SEMICOLON;

BlockOfStatements = LCURLY StatementList RCURLY;

IfStatement = IF LPAREN Expression RPAREN Statement ElseStatement; 

ElseStatement = ELSE Statement
			| 
			;
			
WhileStatement = WHILE LPAREN Expression RPAREN Statement;

BreakStatement = BBREAK SEMICOLON;

ReturnStatement = RETURN SEMICOLON
				| RETURN Expression SEMICOLON
				;
		
ExpressionStatement = Expression SEMICOLON;		

Expression = Assignment
			|RHSExpression
			;
			
Assignment = LHSExpression EQN Expression;

LHSExpression =ID
			  |ArrayAccess
			  ;

ArrayAccess = LHSExpression LBRACKET Expression RBRACKET;

RHSExpression = ArithmetricExpression; 

RHSExpression2 = ArithmetricExpression ComparisonOperator ArithmetricExpression;

ComparisonOperator =EQEQ
 					|NEQ
 					|LT
 					|LEQ
 					|GT
 					|GEQ
 					;
 					
 ArithmetricExpression = ArithmetricExpression AdditiveOperator Term
 						| Term
 						;
 
 AdditiveOperator =PLUS
 				  |MINUS
 				  ;
 
 Term = MultiplicativeOperator Factor
 	  | Factor
 	  ;

MuliplicativeOperator = TIMES
						|DIV
						|MOD
						;

Factor = MINUS Factor
		|PrimaryExpression
		;

PrimaryExpression = LHSExpression
					|FuntionCall
					|ArrayExpression
					|STRING_LITERAL
					|INT_LITERAL
					|TRUE
					|FALSE
					|ParanthesisedExpression
					;

FunctionCall = ID LPAREN EXPressionList RPAREN;

ExpressionList = ExpressionList COMMA Expression
		| Expression
		| 
		;	

NonEmptyExpressionList = NONEmptyExpressionList COMMA Expression;	

ArrayExpression = LBRACKET NonEmptyExpressionList RBRACKET; 

ParanthesisedExpression = LPAREN Expression RPAREN;   

/**/

/* Dummy rule to make the lexer compile. Remove this once you have written all other rules. */	  
Dummy = MODULE INT VOID IF ELSE WHILE RETURN BREAK BOOLEAN PUBLIC TRUE FALSE INT_LITERAL STRING_LITERAL ID TYPE IMPORT
           PLUS MINUS TIMES DIV MOD EQEQ NEQ LEQ GEQ LT GT LBRACKET RPAREN COMMA RCURLY LCURLY SEMICOLON RBRACKET LPAREN EQL;